{"name":"Tenantable","tagline":"Laravel Multi tenancy","body":"## Tenantable\r\n[![Packagist License](https://poser.pugx.org/leemason/tenantable/license.png)](http://choosealicense.com/licenses/mit/)\r\n[![Latest Stable Version](https://poser.pugx.org/leemason/tenantable/version.png)](https://packagist.org/packages/leemason/tenantable)\r\n[![Total Downloads](https://poser.pugx.org/leemason/tenantable/d/total.png)](https://packagist.org/packages/leemason/tenantable)\r\n[![Build Status](https://travis-ci.org/leemason/tenantable.svg?branch=master)](https://travis-ci.org/leemason/tenantable)\r\n\r\nThe Laravel Tenantable package is designed to enable multi-tenancy based database connections on the fly without having to access the database ```::connection('name')``` in every database call.\r\n\r\n## Installation\r\n\r\nJust place require new package for your laravel installation via composer.json\r\n\r\n```\r\ncomposer require leemason/tenantable\r\n```\r\n\r\nThen hit composer update\r\n\r\nAfter updating composer, add the ServiceProvider to the providers array in config/app.php.\r\nYou should ideally have this inserted into the array just after the ```Illuminate\\Database\\DatabaseServiceProvider::class``` to ensure its boot methods is called after the database is available but before any other Service Providers are booted.\r\n\r\n### Laravel 5.1:\r\n\r\n```php\r\nLeeMason\\Tenantable\\TenantableServiceProvider::class,\r\n```\r\n\r\nThen in your workflow create tenants the Eloquent way:\r\n\r\n```php\r\n$tenant = new \\LeeMason\\Tenantable\\Tenant();\r\n$tenant->domain = 'http://domain.com';\r\n$tenant->driver = 'mysql';\r\n$tenant->host = 'localhost';\r\n$tenant->database = 'domain_com';\r\n$tenant->username = 'root';\r\n$tenant->password = '';\r\n$tenant->prefix = 'prefix';\r\n$tenant->save();\r\n```\r\n\r\nAnd that's it! Whenever your app is visited via http://domain.com the default database connection will be set with the above details.\r\n\r\n## Compatibility\r\n\r\nThe Tenantable package has been developed with Laravel 5.1, i see no reason why it wouldn't work with 5.0 but it is only tested for 5.1 and above.\r\n\r\n## Introduction\r\n\r\nThe package simply resolves the correct connection details via the domain accessed via connection details saved in the database.\r\n\r\nOnce resolved it sets the default database connection with the saved values.\r\n\r\nThis prevents the need to keep switching, or programatically accessing the right connection depending on the tenant being accessed.\r\n\r\nThis means all of your routes, models, etc will run on the active tenant database (unless explicitly stated via ```::connection('name')```)\r\n\r\n## Lifecycle\r\n\r\nThis is how things work during a HTTP request:\r\n\r\n- Tenantable copies the name of the default database connection into the ```tenantable.database.default``` config area.\r\n- Tenantable gets the host string via the ```Http\\Request::getHost()``` method.\r\n- Tenantable looks for a tenant in the database that match this host.\r\n- If one isn't found, Tenantable looks in the Domains table to find a match (and if found uses eloquent relationships to return the Tenant model.\r\n- When a match is found, the match is saved as the active tenant, and the database details for the tenant are placed in the ```database.connections.tenant``` config.\r\n- Then the default database connection is changed to 'tenant' and the connection purged (disconnected/reconnected).\r\n- The ```app.url``` config is set the tenants domain.\r\n- If a match isn't found in either tables a TenantNotResolved event is fired and no config changes happen.\r\n\r\nThis is how it works during an artisan console request:\r\n\r\n- Tenantable copies the name of the default database connection into the ```tenantable.database.default``` config area.\r\n- Tenantable registers a console option of ```--tenant``` where you can supply the id,uuid,domain or *,all to run for all tenants.\r\n- Tenantable checks to see if the tenant option is provided, if it isn't no tenant is resolved. The command runs normally.\r\n- If a match is found it resolves the tenant (settings the tenant connection details) before excecuting the command.\r\n- If you provide ```--tenant``` with either a ```*``` or the string ```all``` Tenantable will run the command foreach tenant found in the database, setting the active tenant before running each time.\r\n\r\n## The Resolver Class\r\n\r\nThe ```\\LeeMason\\Tenantable\\Resolver``` class responsible for resolving and managing the active tenant during http and console access.\r\n\r\nThe ```TenantableServiceProvider``` registers this class as a singleton for use anywhere in your app via method injection, or by using the ```app('LeeMason\\Tenantable\\Resolver')``` helper function.\r\n\r\nThis class provides you with methods to access or alter the active tenant:\r\n\r\n```php\r\n//fetch the resolver class either via the app() function or by injecting\r\n$resolver = app('LeeMason\\Tenantable\\Resolver');\r\n\r\n//check if a tenant was resolved\r\n$resolver->isResolved(); // returns bool\r\n\r\n//get the active tenant model\r\n$tenant = $resolver->getActiveTenant(); // returns instance of \\LeeMason\\Tenantable\\Tenant or null\r\n\r\n//set the active tenant\r\n$resolver->setActiveTenant(\\LeeMason\\Tenantable\\Tenant $tenant); // fires a \\LeeMason\\Tenantable\\Events\\SetActiveTenantEvent event\r\n\r\n//purge tenant connection\r\n$resolver->purgeTenantConnection();\r\n\r\n//reconnect tenant connection\r\n$resolver->reconnectTenantConnection();\r\n```\r\n\r\n## The Tenant Model\r\n\r\nThe ```\\LeeMason\\Tenantable\\Tenant``` class is a very simple Eloquent model with some database connection attributes, and a meta attribute which is cast to a ```Illuminate\\Support\\Collection``` when accessed.\r\n\r\nEach attribute (except id,uuid,domain,driver,prefix,meta, and timestamps) are encrypted for security and are decrypted on access, encrypted on save automatically.\r\n\r\nEach model instance is assigned a ```uuid``` upon creation, this attribute cannot be set/changed as its a unique id generated for this tenant.\r\n\r\nThe reason for the uuid is to allow you to use an identifyer for the tenant elsewhere without exposing the tenants id or domain (for example in the filesystem, where you may store tenant specific files in sub folders).\r\n\r\nThe model can be used in any way other Eloquent models are to create/read/update/delete:\r\n\r\n```php\r\n//create by mass assignment\r\n\\LeeMason\\Tenantable\\Tenant::create([\r\n    'domain' => 'http://...'\r\n    ....\r\n]);\r\n\r\n//call then save\r\n$tenant = \\LeeMason\\Tenantable\\Tenant();\r\n$tenant->domain = 'http://...';\r\n...\r\n$tenant->save();\r\n\r\n//fetch all tenants\r\n$tenant = \\LeeMason\\Tenantable\\Tenant::all();\r\n\r\n//fetch by domain\r\n$tenant = \\LeeMason\\Tenantable\\Tenant::where('domain', 'http://..')->first();\r\n```\r\n\r\n## Events\r\n\r\nThe Tenantable packages produces a few events which can be consumed in your application\r\n\r\n```\\LeeMason\\Tenantable\\Events\\SetActiveTenantEvent(\\LeeMason\\Tenantable\\Tenant $tenant)```\r\n\r\nThis event is fired when a tenant is set as the active tenant and has a public ```$tenant``` property containing the ```\\LeeMason\\Tenantable\\Tenant``` instance.\r\n\r\n**Note** this may not be as a result of the resolver but is also fired when a tenant is set to active programatically.\r\n\r\n```\\LeeMason\\Tenantable\\Events\\TenantResolvedEvent(\\LeeMason\\Tenantable\\Tenant $tenant)```\r\n\r\nThis event is fired when a tenant is resolved by the resolver and has a public ```$tenant``` property containing the ```\\LeeMason\\Tenantable\\Tenant``` instance.\r\n\r\n**Note** this is only fired once per request as the resolver is responsible for this event.\r\n\r\n```\\LeeMason\\Tenantable\\Events\\TenantNotResolvedEvent(\\LeeMason\\Tenantable\\Resolver $resolver)```\r\n\r\nThis event is fired when by the resolver when it cannot resolve a tenant and has a public ```$resolver``` property containing the ```\\LeeMason\\Tenantable\\Resolver``` instance.\r\n\r\n**Note** this is only fired once per request as the resolver is responsible for this event.\r\n\r\n#### Notes on using Artisan::call();\r\n\r\nUsing the ```Artisan``` Facade to run a command provides no access to alter the applications active tenant before running (unlike console artisan access).\r\n\r\nBecause of this the currently active tenant will be used.\r\n\r\nTo run the command foreach tenant you will need to fetch all tenants using ```Tenant::all()``` and run the ```Artisan::call()``` method inside a foreach after setting the active tenant like so:\r\n\r\n```php\r\n//fetch the resolver class either via the app() function or by injecting\r\n$resolver = app('LeeMason\\Tenantable\\Resolver');\r\n\r\n//store the current tenant\r\n$resolvedTenant = $resolver->getActiveTenant();\r\n\r\n//fetch all tenants and loop / call command for each\r\n$tenants = \\LeeMason\\Tenantable\\Tenant::all();\r\nforeach($tenants as $tenant){\r\n    $resolver->setActiveTenant($tenant);\r\n    $result = \\Artisan::call('commandname', ['array' => 'of', 'the' => 'arguments']);\r\n}\r\n\r\n//restore the correct tenant\r\n$resolver->setActiveTenant($resolvedTenant);\r\n```\r\n\r\nIf you need to run the Artisan facade on the original default connection (ie not the tenant connection) simply call the ```Resolver::purgeTenantConnection()``` function first:\r\n\r\n```php\r\n//fetch the resolver class either via the app() function or by injecting\r\n$resolver = app('LeeMason\\Tenantable\\Resolver');\r\n\r\n//store the current tenant\r\n$resolvedTenant = $resolver->getActiveTenant();\r\n\r\n//purge the tenant from the default connection\r\n$resolver->purgeTenantConnection();\r\n\r\n//call the command\r\n$result = \\Artisan::call('commandname', ['array' => 'of', 'the' => 'arguments']);\r\n\r\n//restore the tenant connection as the default\r\n$resolver->reconnectTenantConnection();\r\n```\r\n\r\n## The Future\r\n\r\n- Add tests\r\n- Add meta items to laravel config","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}